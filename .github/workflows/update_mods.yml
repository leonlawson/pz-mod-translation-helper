name: è‡ªåŠ¨æ›´æ–°ã€å¤„ç†å¹¶ä¿å­˜Modç¿»è¯‘

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      mod_id_override:
        description: 'å¡«å…¥Mod IDæ¥è¿›è¡Œå¼ºåˆ¶æ›´æ–°'
        required : false
        type: string
      full_refresh:
        description: 'æ˜¯å¦å¼ºåˆ¶åˆ·æ–°æ‰€æœ‰Mod(id_list.txt)'
        required: false
        type: boolean
        default: false
  schedule:
    - cron: '0 4 * * *' # æ¯å¤©UTCæ—¶é—´å‡Œæ™¨4ç‚¹è¿è¡Œ (åŒ—äº¬æ—¶é—´ä¸­åˆ12ç‚¹)

jobs:
  setup_jobs:
    runs-on: ubuntu-latest
    outputs:
      mods_to_download: ${{ steps.combine_lists.outputs.mods_to_download }}
      mod_groups: ${{ steps.split_list.outputs.groups }}
      manual_ids_raw: ${{ github.event.inputs.mod_id_override }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Reusable Environment
        uses: ./.github/actions/setup-environment
        with:
          install-jq: 'true'

      - name: Handle Manual Trigger Override
        id: manual_check
        if: github.event.inputs.mod_id_override != ''
        run: |
          MOD_IDS_STRING='${{ github.event.inputs.mod_id_override }}'
          echo "æ‰‹åŠ¨è§¦å‘æ¨¡å¼: å‡†å¤‡å¤„ç†ä»¥ä¸‹ Mod ID: $MOD_IDS_STRING"
          CLEAN_JSON_ARRAY=$(echo "$MOD_IDS_STRING" | sed 's/[^0-9]/\ /g' | grep -oE '[0-9]+' | awk '/^[0-9]{8,12}$/' | sort -u | jq -Rsc 'split("\n") | map(select(. != ""))')
          echo "è½¬æ¢åçš„JSONæ•°ç»„(å·²æ¸…ç†å¹¶å»é‡): $CLEAN_JSON_ARRAY"
          echo "mods_to_download=$CLEAN_JSON_ARRAY" >> $GITHUB_OUTPUT

      - name: Handle Full Refresh Trigger
        id: full_refresh_check
        if: github.event.inputs.full_refresh == 'true' && github.event.inputs.mod_id_override == ''
        run: |
          echo "å¼ºåˆ¶åˆ·æ–°æ¨¡å¼: æ­£åœ¨è¯»å– id_list.txt ä¸­çš„æ‰€æœ‰ Mod ID..."
          if [ ! -f "id_list.txt" ]; then
            echo "::error::id_list.txt æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¼ºåˆ¶åˆ·æ–°ã€‚è¯·ç¡®ä¿æ–‡ä»¶ä½äºä»“åº“æ ¹ç›®å½•ã€‚"
            exit 1
          fi
          ALL_MOD_IDS=$(cat id_list.txt | sed 's/[^0-9]/\ /g' | grep -oE '[0-9]+' | awk '/^[0-9]{8,12}$/' | sort -u | jq -Rsc 'split("\n") | map(select(. != ""))')
          echo "å·²ä» id_list.txt è¯»å–æ‰€æœ‰ Mod ID: $ALL_MOD_IDS"
          echo "mods_to_download=$ALL_MOD_IDS" >> $GITHUB_OUTPUT

      - name: Smart Check for Mod Updates (Scheduled/Default)
        id: scheduled_check
        if: github.event.inputs.full_refresh != 'true'
        env:
          STEAM_API_KEY: ${{ secrets.STEAM_API_KEY }}
        run: python scripts/check_updates.py

      - name: Upload Timestamp Artifact
        if: steps.scheduled_check.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: mod-timestamps-artifact
          path: translation_utils/mod_timestamps.json
          retention-days: 1

      - name: Check for Local Completion File Updates
        id: local_check
        if: github.event.inputs.mod_id_override == '' && github.event.inputs.full_refresh != 'true'
        run: |
          python scripts/check_local_changes.py > local_changes.json
          echo 'mods_to_download<<EOF' >> "$GITHUB_OUTPUT"
          cat local_changes.json >> "$GITHUB_OUTPUT"
          echo 'EOF' >> "$GITHUB_OUTPUT"

      - name: Combine update lists
        id: combine_lists
        env:
          MANUAL_LIST_INPUT: ${{ steps.manual_check.outputs.mods_to_download }}
          FULL_REFRESH_LIST_INPUT: ${{ steps.full_refresh_check.outputs.mods_to_download }}
          SCHEDULED_LIST_INPUT: ${{ steps.scheduled_check.outputs.mods_to_download }}
          LOCAL_CHANGES_LIST_INPUT: ${{ steps.local_check.outputs.mods_to_download }}

        run: |
          MANUAL_LIST="$MANUAL_LIST_INPUT"
          FULL_REFRESH_LIST="$FULL_REFRESH_LIST_INPUT"
          SCHEDULED_LIST="$SCHEDULED_LIST_INPUT"
          LOCAL_CHANGES_LIST="$LOCAL_CHANGES_LIST_INPUT"

          if [ -z "$MANUAL_LIST" ] || [ "$MANUAL_LIST" = "null" ]; then MANUAL_LIST='[]'; fi
          if [ -z "$FULL_REFRESH_LIST" ] || [ "$FULL_REFRESH_LIST" = "null" ]; then FULL_REFRESH_LIST='[]'; fi
          if [ -z "$SCHEDULED_LIST" ] || [ "$SCHEDULED_LIST" = "null" ]; then SCHEDULED_LIST='[]'; fi
          if [ -z "$LOCAL_CHANGES_LIST" ] || [ "$LOCAL_CHANGES_LIST" = "null" ]; then LOCAL_CHANGES_LIST='[]'; fi
          COMBINED_LIST='[]'
          
          if [ "$MANUAL_LIST" != "[]" ]; then
            echo "æ£€æµ‹åˆ°æ‰‹åŠ¨Mod IDè¦†ç›–ï¼Œå°†ä½¿ç”¨æ­¤åˆ—è¡¨è¿›è¡Œå¤„ç† (ä¼˜å…ˆçº§æœ€é«˜)ã€‚"
            COMBINED_LIST=$(echo "$MANUAL_LIST" | jq -c '.')
          elif [ "$FULL_REFRESH_LIST" != "[]" ]; then
            echo "æ£€æµ‹åˆ°å¼ºåˆ¶åˆ·æ–°æ¨¡å¼ï¼Œå°†ä½¿ç”¨ id_list.txt ä¸­çš„æ‰€æœ‰Mod IDè¿›è¡Œå¤„ç†ã€‚"
            COMBINED_LIST=$(echo "$FULL_REFRESH_LIST" | jq -c '.')
          else
            echo "æœªæ£€æµ‹åˆ°æ‰‹åŠ¨è¦†ç›–æˆ–å¼ºåˆ¶åˆ·æ–°ã€‚å°†ä½¿ç”¨è‡ªåŠ¨æ£€æŸ¥çš„Modåˆ—è¡¨ã€‚"
            
            echo " - Steamæ›´æ–°åˆ—è¡¨: $SCHEDULED_LIST"
            echo " - æœ¬åœ°å˜æ›´åˆ—è¡¨: $LOCAL_CHANGES_LIST"
            
            COMBINED_LIST=$(jq -n --argjson a "$SCHEDULED_LIST" --argjson b "$LOCAL_CHANGES_LIST" '($a + $b) | unique' | jq -c '.')
          fi
          
          echo "æœ€ç»ˆå¾…å¤„ç†çš„Modåˆ—è¡¨: $COMBINED_LIST"
          echo "mods_to_download=$COMBINED_LIST" >> $GITHUB_OUTPUT

      - name: Calculate Mods per Job
        if: steps.combine_lists.outputs.mods_to_download != '[]' && steps.combine_lists.outputs.mods_to_download != ''
        id: job_calculator
        env:
          COMBINED_MODS_JSON: ${{ steps.combine_lists.outputs.mods_to_download }}
        run: |
          MODS_PER_JOB=$(python scripts/calculate_jobs.py "$COMBINED_MODS_JSON")
          echo "mods_per_job=$MODS_PER_JOB" >> $GITHUB_OUTPUT

      - name: Split Mod List into Groups for Parallel Jobs
        if: steps.combine_lists.outputs.mods_to_download != '[]' && steps.combine_lists.outputs.mods_to_download != ''
        id: split_list
        env:
          COMBINED_MODS_JSON: ${{ steps.combine_lists.outputs.mods_to_download }}
          MODS_PER_JOB_VAL: ${{ steps.job_calculator.outputs.mods_per_job }}
        run: |
          {
            echo 'groups<<EOF'
            python scripts/split_ids.py "$COMBINED_MODS_JSON" "$MODS_PER_JOB_VAL"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"


  download_parallel:
    needs: setup_jobs
    if: needs.setup_jobs.outputs.mods_to_download != '[]' && needs.setup_jobs.outputs.mods_to_download != ''
    runs-on: ubuntu-latest
    strategy:
      matrix:
        mod_group: ${{ fromJson(needs.setup_jobs.outputs.mod_groups) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Reusable Environment
        uses: ./.github/actions/setup-environment
        with:
          install-jq: 'false'

      - name: Setup SteamCMD
        uses: CyberAndrii/setup-steamcmd@v1

      - name: Download Mod Group (Job ${{ strategy.job-index}})
        env:
          MOD_GROUP_JSON: ${{ toJson(matrix.mod_group) }}
        run: |
          MODS_JSON="$MOD_GROUP_JSON"
          echo "æ­¤ä»»åŠ¡å°†ä¸‹è½½ä»¥ä¸‹Mod: $MODS_JSON"
          
          for MOD_ID in $(echo "$MODS_JSON" | jq -r '.[]'); do
            echo "--> [ID: $MOD_ID] æ­£åœ¨ä¸‹è½½..."
            APP_ID="108600"
            for i in {1..3}; do
              steamcmd +@sSteamCmdForcePlatformType linux +login anonymous +workshop_download_item "$APP_ID" "$MOD_ID" validate +quit && break
              echo "    ä¸‹è½½å¤±è´¥ã€‚15ç§’åé‡è¯•... (ç¬¬ $i/3 æ¬¡å°è¯•)"
              sleep 15
            done

            DOWNLOADED_MOD_PATH="${HOME}/Steam/steamapps/workshop/content/$APP_ID/$MOD_ID"
            if [ -d "$DOWNLOADED_MOD_PATH" ]; then
                DEST_PATH="temp_workshop_full/$MOD_ID"
                mkdir -p "$DEST_PATH"
                rsync -a "$DOWNLOADED_MOD_PATH/" "$DEST_PATH/"
                echo "    [ID: $MOD_ID] ä¸‹è½½å®Œæˆã€‚"
            else
                echo "    è­¦å‘Š: [ID: $MOD_ID] 3æ¬¡é‡è¯•åä¸‹è½½ä»ç„¶å¤±è´¥ã€‚"
            fi
          done

      - name: Prune and Prepare Mods for Artifact Upload
        run: |
          echo "å¼€å§‹ä¿®å‰ªå·²ä¸‹è½½çš„Modï¼Œä»…ä¿ç•™ EN/CN ç›¸å…³ç¿»è¯‘æ–‡ä»¶..."
          mkdir -p pruned_mods
          find ./temp_workshop_full -mindepth 1 -maxdepth 1 -type d | while read MOD_DIR; do
            MOD_ID=$(basename "$MOD_DIR")
            STAGING_DIR="pruned_mods/$MOD_ID"
            mkdir -p "$STAGING_DIR"
            
            rsync -a --prune-empty-dirs \
              --include='*/' \
              --include='**/mod.info' \
              --include='**/media/scripts/***' \
              --include='**/[Tt]ranslate/*[Ee][Nn]*/***' \
              --include='**/[Tt]ranslate/*[Cc][Nn]*/***' \
              --exclude='**/[Tt]ranslate/*' \
              --exclude='*' \
              "$MOD_DIR/" "$STAGING_DIR/"

            if [ -n "$(find "$STAGING_DIR" -type f -print -quit)" ]; then
                echo "    [ID: $MOD_ID] Modä¿®å‰ªå®Œæˆï¼ŒåŒ…å«æ–‡ä»¶ã€‚"
            else
                echo "    è­¦å‘Š: [ID: $MOD_ID] Modä¿®å‰ªåç›®å½•ä¸ºç©ºï¼Œå¯èƒ½æ²¡æœ‰ç¿»è¯‘ç›¸å…³æ–‡ä»¶æˆ–åŸå§‹ä¸‹è½½å¤±è´¥ã€‚"
            fi
          done
          echo "Modä¿®å‰ªæµç¨‹å®Œæˆã€‚"

      - name: Compress Pruned Mods
        run: |
          echo "æ­£åœ¨å°†ä¿®å‰ªåçš„æ–‡ä»¶å‹ç¼©ä¸º tar.gz ..."
          tar -czf pruned-mods-${{ strategy.job-index }}.tar.gz -C pruned_mods/ .
          echo "å‹ç¼©å®Œæˆã€‚"

      - name: Upload Pruned and Compressed Mod Group Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pruned-mods-${{ strategy.job-index }}
          path: pruned-mods-${{ strategy.job-index }}.tar.gz
          retention-days: 1

  process_and_commit:
    needs: [setup_jobs, download_parallel]
    if: needs.setup_jobs.outputs.mods_to_download != '[]' && needs.setup_jobs.outputs.mods_to_download != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download Timestamp Artifact to Correct Path
        uses: actions/download-artifact@v4
        with:
          name: mod-timestamps-artifact
          path: translation_utils/
          if-no-files-found: ignore

      - name: Setup Reusable Environment
        uses: ./.github/actions/setup-environment
        with:
          install-jq: 'true'
          
      - name: Download all Pruned Mod Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: pruned-mods-*
          path: temp_artifacts/
          merge-multiple: false

      - name: Prepare workshop_content for updates
        env:
          MODS_TO_DOWNLOAD_JSON_FROM_OUTPUT: ${{ needs.setup_jobs.outputs.mods_to_download }}
        run: |
          TMP_DIRS=()
          
          cleanup() {
            echo "æ­£åœ¨æ‰§è¡Œæ¸…ç†æ“ä½œ..."
            for d in "${TMP_DIRS[@]}"; do
              if [ -d "$d" ]; then
                echo "  -> ç§»é™¤ä¸´æ—¶ç›®å½•: $d"
                rm -rf "$d"
              fi
            done
            echo "æ¸…ç†å®Œæˆã€‚"
          }
          
          trap cleanup EXIT # ç¡®ä¿åœ¨è„šæœ¬é€€å‡ºæ—¶è°ƒç”¨ cleanup å‡½æ•°

          echo "å‡†å¤‡ ./data/workshop_content ç›®å½•ï¼Œåˆå¹¶ç°æœ‰å†…å®¹ä¸æ–°ä¸‹è½½çš„Mod..."
          mkdir -p ./data/workshop_content

          MODS_TO_UPDATE_JSON="$MODS_TO_DOWNLOAD_JSON_FROM_OUTPUT"

          if [ -n "$MODS_TO_UPDATE_JSON" ] && [ "$MODS_TO_UPDATE_JSON" != "[]" ] && [ "$MODS_TO_UPDATE_JSON" != "null" ]; then
            echo "æ­£åœ¨æ¸…é™¤æœ¬æ¬¡æ›´æ–°Modçš„æ—§ç›®å½•..."
            for MOD_ID in $(echo "$MODS_TO_UPDATE_JSON" | jq -r '.[]'); do
              MOD_DIR="./data/workshop_content/$MOD_ID"
              if [ -d "$MOD_DIR" ]; then
                echo "  -> ç§»é™¤æ—§ç‰ˆModç›®å½•: $MOD_DIR"
                rm -rf "$MOD_DIR"
              else
                echo "  -> ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡åˆ é™¤: $MOD_DIR"
              fi
            done
          else
            echo "  -> æ²¡æœ‰Modéœ€è¦æ›´æ–°æˆ–æ–°å¢ï¼Œè·³è¿‡æ¸…é™¤æ—§ç›®å½•æ­¥éª¤ã€‚"
          fi

          echo "æ­£åœ¨è§£å‹å¹¶åŒæ­¥æ›´æ–°åçš„Modæ–‡ä»¶..."
          while IFS= read -r archive; do
            if [ -f "$archive" ]; then
              echo "  -> æ­£åœ¨å¤„ç†å‹ç¼©åŒ…: $(basename "$archive")"
              TMP_EXTRACT_DIR=$(mktemp -d)
              TMP_DIRS+=("$TMP_EXTRACT_DIR")
              
              if ! tar -xzf "$archive" -C "$TMP_EXTRACT_DIR"; then
                echo "  -> è­¦å‘Š: è§£å‹ $archive å¤±è´¥ï¼Œè·³è¿‡æ­¤æ–‡ä»¶ã€‚"
                continue
              fi

              for MOD_SUB_DIR in "$TMP_EXTRACT_DIR"/*; do
                if [ -d "$MOD_SUB_DIR" ]; then
                  MOD_ID=$(basename "$MOD_SUB_DIR")
                  DEST_MOD_DIR="./data/workshop_content/$MOD_ID"
                  
                  echo "    -> åŒæ­¥Mod $MOD_ID åˆ° $DEST_MOD_DIR"
                  mkdir -p "$DEST_MOD_DIR"
                  rsync -a --delete "$MOD_SUB_DIR/" "$DEST_MOD_DIR/"
                fi
              done
            fi
          done < <(find temp_artifacts -type f -name "pruned-mods-*.tar.gz")
          echo "æ‰€æœ‰Modå†…å®¹å·²åˆå¹¶å¹¶å‡†å¤‡å°±ç»ªã€‚"

      - name: Clean up temporary artifacts
        run: rm -rf temp_artifacts    

      - name: Dynamically Add New Mod IDs to id_list.txt
        if: needs.setup_jobs.outputs.manual_ids_raw != ''
        env:
          MODS_TO_ADD_JSON: ${{ needs.setup_jobs.outputs.mods_to_download }}
        run: |
          CLEANED_MODS_JSON="$MODS_TO_ADD_JSON"
          
          [ -n "$(tail -c1 id_list.txt)" ] && echo >> id_list.txt
          
          for ID in $(echo "$CLEANED_MODS_JSON" | jq -r '.[]'); do
            if grep -q -w -x "$ID" id_list.txt; then
              echo "  -> ID: $ID å·²å­˜åœ¨äº id_list.txt ä¸­ï¼Œæ— éœ€æ·»åŠ ã€‚"
            else
              echo "  -> ID: $ID æ˜¯æ–°IDï¼Œæ­£åœ¨æ·»åŠ åˆ° id_list.txt..."
              echo "$ID" >> id_list.txt
            fi
          done
          echo "id_list.txt æ›´æ–°å®Œæˆã€‚"

      - name: Update Timestamps After Successful Download
        env:
          STEAM_API_KEY: ${{ secrets.STEAM_API_KEY }}
          MODS_TO_DOWNLOAD_JSON_FOR_TIMESTAMP: ${{ needs.setup_jobs.outputs.mods_to_download }}
        run: |
          MODS_DOWNLOADED="$MODS_TO_DOWNLOAD_JSON_FOR_TIMESTAMP"
          MAP_FILE="translation_utils/mod_id_name_map.json"

          if [ -z "$MODS_DOWNLOADED" ] || [ "$MODS_DOWNLOADED" = "[]" ] || [ "$MODS_DOWNLOADED" = "null" ]; then
            echo "æ²¡æœ‰éœ€è¦æ›´æ–°æ˜ å°„çš„Modã€‚"
            exit 0
          fi
          
          # APIè°ƒç”¨ä»¥è·å–å½“å‰æ‰¹æ¬¡Modçš„è¯¦æƒ…
          POST_DATA=$(echo "$MODS_DOWNLOADED" | jq -r 'to_entries[] | "publishedfileids[\(.key)]=\(.value)"' | paste -sd '&')
          ITEM_COUNT=$(echo "$MODS_DOWNLOADED" | jq 'length')
          API_RESPONSE_BATCH=$(curl --retry 5 --retry-delay 5 --retry-all-errors -s -X POST "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/" -d "itemcount=$ITEM_COUNT" -d "$POST_DATA")
          if ! echo "$API_RESPONSE_BATCH" | jq -e '.response.publishedfiledetails' > /dev/null; then
             echo "::error::Steam APIè°ƒç”¨å¤±è´¥æˆ–è¿”å›æ— æ•ˆæ•°æ®ã€‚"
             exit 1
          fi
          echo "$API_RESPONSE_BATCH" > api_response.json
          
          echo "æ­£åœ¨å¯¹ Mod ID-åç§°æ˜ å°„æ–‡ä»¶è¿›è¡Œå¢é‡æ›´æ–°"
          if [ ! -f "$MAP_FILE" ]; then
            echo "æœªæ‰¾åˆ°ç°æœ‰æ˜ å°„æ–‡ä»¶ï¼Œå°†åˆ›å»ºä¸€ä¸ªæ–°çš„ã€‚"
            echo "{}" > "$MAP_FILE"
          fi
          
          # ä¸ºå½“å‰æ‰¹æ¬¡çš„Modç”Ÿæˆä¸€ä¸ªæ–°çš„æ˜ å°„ç‰‡æ®µ
          NEW_MAP_CHUNK=$(jq '.response.publishedfiledetails | map(if .title and .result == 1 then {(.publishedfileid): .title} else {(.publishedfileid): null} end) | add' api_response.json)
          
          # åˆå¹¶æ–°æ—§æ•°æ®ã€‚å¦‚æœIDå·²å­˜åœ¨ï¼Œæ–°å€¼ä¼šè¦†ç›–æ—§å€¼ã€‚
          jq -s '.[0] * .[1] | to_entries | sort_by(.key | tonumber) | from_entries' "$MAP_FILE" <(echo "$NEW_MAP_CHUNK") > tmp_map.json && mv tmp_map.json "$MAP_FILE"
          
          echo "Mod ID-åç§°æ˜ å°„æ–‡ä»¶ ($MAP_FILE) å·²æˆåŠŸå¢é‡æ›´æ–°ã€‚"

      - name: Run Main Translation Extractor Script
        env:
          TZ: Asia/Shanghai
          MODS_FOR_PYTHON: ${{ needs.setup_jobs.outputs.mods_to_download }}
        run: python scripts/process_mods.py "$MODS_FOR_PYTHON"

      - name: Prepare Pull Request Body
        id: prep_pr
        env:
          MODS_TO_DOWNLOAD_JSON_FOR_PR: ${{ needs.setup_jobs.outputs.mods_to_download }}
        run: |
          MODS_JSON="$MODS_TO_DOWNLOAD_JSON_FOR_PR"
          
          # æ£€æŸ¥æ˜¯å¦æœ‰éœ€è¦æ›´æ–°çš„Mod
          if [ -z "$MODS_JSON" ] || [ "$MODS_JSON" = "[]" ] || [ "$MODS_JSON" = "null" ]; then
            echo "æ²¡æœ‰éœ€è¦æ›´æ–°çš„Modï¼Œæ— éœ€åˆ›å»ºPRã€‚"
            echo "should_create_pr=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "should_create_pr=true" >> $GITHUB_OUTPUT
          
          PR_BODY_FILE="pr_body.md"
          echo "### ğŸ¤– è‡ªåŠ¨åŒ–Modæ›´æ–°æŠ¥å‘Š" > "$PR_BODY_FILE"
          echo "" >> "$PR_BODY_FILE"
          echo "æ£€æµ‹åˆ°ä»¥ä¸‹Modæœ‰æ›´æ–°ï¼Œç›¸å…³ç¿»è¯‘æ–‡ä»¶å·²è‡ªåŠ¨ç”Ÿæˆï¼š" >> "$PR_BODY_FILE"
          echo "" >> "$PR_BODY_FILE"
          
          MOD_LIST_MARKDOWN=$(jq --argjson ids "$MODS_JSON" -r '
            (.response.publishedfiledetails | map({(.publishedfileid): (.title // "æœªçŸ¥Mod")}) | add) as $details |
            $ids[] |
            "- [**\($details[.])**](https://steamcommunity.com/sharedfiles/filedetails/?id=\(.)) (ID: `\(.)`)"
          ' api_response.json)
          echo "$MOD_LIST_MARKDOWN" >> "$PR_BODY_FILE"
          
          echo "" >> "$PR_BODY_FILE"
          echo "---" >> "$PR_BODY_FILE"
          echo "è¯·å®¡æ ¸æ–‡ä»¶å˜æ›´ï¼Œç¡®è®¤æ— è¯¯åå³å¯åˆå¹¶æ­¤æ‹‰å–è¯·æ±‚ã€‚" >> "$PR_BODY_FILE"
          echo "å·¥ä½œæµè¿è¡Œæ—¥å¿—: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> "$PR_BODY_FILE"
      
      - name: Set Today's Date
        id: set_date
        run: echo "TODAY=$(date +'%Y-%m-%d')" >> $GITHUB_ENV    
      
      - name: Create, Approve, and Merge PR
        if: steps.prep_pr.outputs.should_create_pr == 'true'
        uses: ./.github/actions/create-approve-merge-pr
        with:
          branch-name: bot/auto-update-${{ github.run_id }}
          pr-title: 'ğŸ¤– è‡ªåŠ¨åŒ–Modæ›´æ–°ä¸æŠ¥å‘Š [${{ env.TODAY }}]'
          pr-body-path: "pr_body.md"
          commit-message: |
            Chore(è‡ªåŠ¨åŒ–): æ›´æ–°Modå¹¶ç”ŸæˆæŠ¥å‘Š
            
            æœ¬æ¬¡è¿è¡Œ (ID: ${{ github.run_id }}) çš„å˜æ›´åŒ…æ‹¬:
            - æ›´æ–°äº†å—å½±å“Modçš„ç¿»è¯‘æ–‡ä»¶ã€‚
            - ç”Ÿæˆäº†æ–°çš„çŠ¶æ€æŠ¥å‘Š (STATUS.md, INTERNAL_STATUS.md, MOD_TODO_STATUS.md)ã€‚
            - æ›´æ–°äº†å¢é‡æ—¥å¿— (data/logs/update_log.json)ã€‚
            - å­˜æ¡£äº†æ–°çš„åŸºçº¿æ—¥å¿— (å¦‚æœé€‚ç”¨)ã€‚
          labels: "automated-update, bot"
          app-id: ${{ secrets.AUTO_MERGE_BOT_APP_ID }}
          installation-id: ${{ secrets.AUTO_MERGE_BOT_INSTALLATION_ID }}
          private-key: ${{ secrets.AUTO_MERGE_BOT_APP_PRIVATE_KEY }}
          approver-token: ${{ secrets.APPROVER_BOT_PAT }}

      # - name: Approve the auto-generated PR
      #   if: steps.cpr.outputs.pull-request-number != ''
      #   env:
      #     GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #     PR_NUMBER: ${{ steps.cpr.outputs.pull-request-number }}
      #   run: |
      #     echo "è‡ªåŠ¨æ‰¹å‡†ç”±æœ¬å·¥ä½œæµåˆ›å»ºçš„ PR #${PR_NUMBER}..."
      #     gh pr review --approve "$PR_NUMBER"
      #     echo "æ‰¹å‡†æˆåŠŸã€‚"

      # - name: Enable auto-merge for the PR
      #   if: steps.cpr.outputs.pull-request-number != ''
      #   env:
      #     GH_TOKEN: ${{ secrets.AUTOMERGE_PAT }}
      #     PR_NUMBER: ${{ steps.cpr.outputs.pull-request-number }}
      #   run: |
      #     echo "ä¸º PR #${PR_NUMBER} å¯ç”¨è‡ªåŠ¨åˆå¹¶..."
      #     gh pr merge --auto --squash "$PR_NUMBER"
      #     echo "è‡ªåŠ¨åˆå¹¶å·²æˆåŠŸå¯ç”¨ã€‚å½“æ‰€æœ‰æ£€æŸ¥é€šè¿‡åï¼ŒGitHubå°†ä¼šè‡ªåŠ¨åˆå¹¶æ­¤PRã€‚"

      - name: Prepare Issue Body on Failure
        if: failure()
        id: prep_issue
        env:
          WORKFLOW_NAME: ${{ github.workflow }}
          EVENT_NAME: ${{ github.event_name }}
          ACTOR_NAME: ${{ github.actor }}
          BRANCH_NAME: ${{ github.ref }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          ISSUE_BODY_FILE="issue_body.md"
          echo "### ğŸš¨ å·¥ä½œæµè¿è¡Œå¤±è´¥æŠ¥å‘Š" > "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "**å·¥ä½œæµ:** \`$WORKFLOW_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "**è§¦å‘äº‹ä»¶:** \`$EVENT_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "**è§¦å‘è€…:** \`$ACTOR_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "**åˆ†æ”¯:** \`$BRANCH_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "---" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "#### ğŸ”´ å¤±è´¥è¯¦æƒ…" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "æœ¬æ¬¡è‡ªåŠ¨åŒ–å·¥ä½œæµåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­æ„å¤–ä¸­æ–­ã€‚è¯·ç«‹å³æ£€æŸ¥ç›¸å…³çš„è¿è¡Œæ—¥å¿—ä»¥è¯Šæ–­é—®é¢˜ã€‚" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "**â¡ï¸ ç‚¹å‡»æ­¤å¤„æŸ¥çœ‹è¯¦ç»†è¿è¡Œæ—¥å¿— [<sup>1</sup>]($RUN_URL)**" >> "$ISSUE_BODY_FILE"
          echo "filename=$ISSUE_BODY_FILE" >> $GITHUB_OUTPUT

      - name: Create Issue on Failure
        if: failure()
        uses: peter-evans/create-issue-from-file@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          title: "ğŸš¨ å·¥ä½œæµå¤±è´¥: è‡ªåŠ¨æ›´æ–°Modç¿»è¯‘"
          content-filepath: ${{ steps.prep_issue.outputs.filename }}
          labels: "bug, CI/CD, automated report"
          assignees: 'Laotian21'
      
      - name: Trigger CI workflow From Mod Update Workflow
        uses: peter-evans/repository-dispatch@v2
        if: ${{ false && success() }}  # è¯¥workflowä¼šè‡ªåŠ¨ç”Ÿæˆä¸€æ¬¡æäº¤å¹¶è¢«CIæ•è·ï¼Œæ­¤å¤„æ— éœ€è§¦å‘CI
        with:
          token: ${{ secrets.GITHUB_TOKEN }}  # æˆ–ä½¿ç”¨ PATï¼Œå¦‚æœéœ€è¦è·¨ä»“åº“
          event-type: trigger-ci
          client-payload: |
            {
              "source_workflow": "auto_update_mods",
              "run_id": "${{ github.run_id }}"
            }
